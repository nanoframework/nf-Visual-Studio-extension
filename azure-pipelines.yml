trigger:
  branches:
    include: [main, develop, "release-*" ]
  paths:
    exclude: [README.md, LICENSE.md, NuGet.Config, .github_changelog_generator, .gitignore]
  tags:
    include: ["v*"]

# PR always trigger build
pr:
  autoCancel: true

# add nf-tools repo to resources (for Azure Pipelines templates)
resources:
  repositories:
    - repository: templates
      type: github
      name: nanoframework/nf-tools
      endpoint: nanoframework

jobs:

##############################
- job: Get_Build_Options
  pool:
    vmImage: 'windows-latest'

  steps:
  - checkout: self

  # check which project(s) have changed
  - powershell: |
      git config --global user.email "nfbot"
      git config --global user.name "nanoframework@outlook.com"

      $auth = "basic $([System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(":$(GitHubToken)"))))"

      $commit = Invoke-RestMethod -Uri "https://api.github.com/repos/nanoframework/nf-Visual-Studio-extension/commits/$(Build.SourceVersion)" -Header @{"Authorization"="$auth"} -ContentType "application/json" -Method GET
      Write-host "Files changed:"
      $commit.files | % {$_.filename}

      # default values 
      echo "##vso[task.setvariable variable=BUILD_VS2019_2022;isOutput=true]false"  

      if( ($commit.files.filename -like "*CSharp.AssemblyInfoTemplate*") -Or
          ($commit.files.filename -like "*CSharp.BlankApplication*") -Or
          ($commit.files.filename -like "*CSharp.ClassLibrary*") -Or
          ($commit.files.filename -like "*CSharp.ClassTemplate*") -Or
          ($commit.files.filename -like "*CSharp.ResourceTemplate*") -Or
          ($commit.files.filename -like "*Tools.BuildTasks*") -Or
          ($commit.files.filename -like "*Tools.BuildTasks-2019*") -Or
          ($commit.files.filename -like "*Tools.CorHelper*") -Or
          ($commit.files.filename -like "*Tools.MetaDataProcessor*") -Or
          ($commit.files.filename -like "*Tools.Parser*")
        )
      {
          # global changes, build both
          echo "##vso[task.setvariable variable=BUILD_VS2019_2022;isOutput=true]true"  
      }
      else
      {
        if( $commit.files.filename -like "*nanoFramework.Tools.VisualStudio.sln")
        {
          # changes here impact VS2022 and VS2019
          echo "##vso[task.setvariable variable=BUILD_VS2019_2022;isOutput=true]true"  
        }
        if( $commit.files.filename -like "*VisualStudio.Extension-2019/*" )
        {
          # changes here only impact VS2022 and VS2019
          echo "##vso[task.setvariable variable=BUILD_VS2019_2022;isOutput=true]true"
        }
        if( $commit.files.filename -like "*VisualStudio.Extension-2022/*" )
        {
          # changes here only impact VS2022
          echo "##vso[task.setvariable variable=BUILD_VS2019_2022;isOutput=true]true"
        }
      }

    name: BuildOptions
    displayName: get list of changed paths

  - powershell: |
      # read VS2019 manifest file
      $vs2019Manifest = Get-Content VisualStudio.Extension-2019/source.extension.vsixmanifest -Encoding utf8

      $VersionFormatChecks = $vs2019Manifest | Where-Object {$_.ToString() -match "(?>Version=""\|%CurrentProject%;GetBuildVersion\|"")"}
      if($null -eq $VersionFormatChecks)
      {
          Write-Host "***************************************************"
          Write-Host "* WRONG format on version in VS2019 manifest file *"
          Write-Host "***************************************************"
          exit 1
      }

      # read VS2022 manifest file
      $vs2022Manifest = Get-Content VisualStudio.Extension-2022/source.extension.vsixmanifest -Encoding utf8

      $VersionFormatChecks = $vs2022Manifest | Where-Object {$_.ToString() -match "(?>Version=""\|%CurrentProject%;GetBuildVersion\|"")"}
      if($null -eq $VersionFormatChecks)
      {
          Write-Host "***************************************************"
          Write-Host "* WRONG format on version in VS2022 manifest file *"
          Write-Host "***************************************************"
          exit 1
      }
    displayName: Check proper version format

######################
- job: VS2019_2022
  condition: >-
    or(
      eq(dependencies.Get_Build_Options.outputs['BuildOptions.BUILD_VS2019_2022'], true),
      eq(variables['BUILD_VS2019'], 'true'),
      eq(variables['BUILD_VS2022'], 'true')
    )
  dependsOn:
  - Get_Build_Options

  pool:
    vmImage: 'windows-2022'

  variables:
    solution: '**/nanoFramework.Tools.VisualStudio.sln'
    buildConfiguration: 'Release'

  steps:

  # need this here in order to persist GitHub credentials AND init submodules
  - checkout: self
    submodules: true

  - script: |
      git config --global user.email 'nanoframework@outlook.com'
      git config --global user.name 'nfbot'
    displayName: Setup git identity

  - template: azure-pipelines-templates/install-nuget.yml@templates

  - task: NuGetCommand@2
    inputs:
      restoreSolution: '$(solution)'
      feedsToUse: config
      nugetConfigPath: NuGet.config
      verbosityRestore: quiet

  - task: VSBuild@1
    inputs:
      solution: '$(solution)'
      msbuildArgs: '/p:PublicRelease=true'
      configuration: '$(buildConfiguration)'

  # we don't have tests (yet)
  # - task: VSTest@2
  #   inputs:
  #     platform: '$(buildPlatform)'
  #     configuration: '$(buildConfiguration)'

  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            Write-Host "VS2019+2022 build version $env:NBGV_AssemblyVersion"
            
            echo "##vso[task.setvariable variable=BUILD_VERSION;isOutput=true]$env:NBGV_AssemblyVersion"  

    condition: succeeded()
    name: VS2019_2022_Build
    displayName: Store VS2019+2022 build version

  - task: CopyFiles@1
    inputs:
      sourceFolder: $(Build.SourcesDirectory)
      Contents: |
        **\*VS2019.Extension.vsix
        **\vs2019-extension-manifest.json
        **\vs2019-marketplace-overview.md
        **\vs2019\debug-session.png
        **\vs2019\starting-new-project.png
      TargetFolder: '$(Build.ArtifactStagingDirectory)\vs2019'
      flattenFolders: true
    condition: succeeded()
    displayName: Collecting VS2019 deployable artifacts

  - task: CopyFiles@1
    inputs:
      sourceFolder: $(Build.SourcesDirectory)
      Contents: |
        **\*VS2022.Extension.vsix
        **\vs2022-extension-manifest.json
        **\vs2022-marketplace-overview.md
        **\vs2022\debug-session.png
        **\vs2022\starting-new-project.png
      TargetFolder: '$(Build.ArtifactStagingDirectory)\vs2022'
      flattenFolders: true
    condition: succeeded()
    displayName: Collecting VS2022 deployable artifacts

  - task: DotNetCoreCLI@2
    displayName: Install SignTool tool
    condition: and( succeeded(), eq(variables['System.PullRequest.PullRequestId'], '') )
    inputs:
      command: custom
      custom: tool
      arguments: install --tool-path . SignClient
  
  - pwsh: |
      .\SignClient "Sign" `
      --baseDirectory "$(Build.ArtifactStagingDirectory)\vs2019" `
      --input "**\*.vsix" `
      --config "$(Build.Repository.LocalPath)\config\SignClient.json" `
      --filelist "$(Build.Repository.LocalPath)\config\filelist.txt" `
      --user "$(SignClientUser)" `
      --secret '$(SignClientSecret)' `
      --name ".NET nanoFramework VS2019 Extension" `
      --description ".NET nanoFramework VS2019 Extension" `
      --descriptionUrl "https://github.com/$env:Build_Repository_Name"
    displayName: Sign VS2019 packages
    condition: and( succeeded(), eq(variables['System.PullRequest.PullRequestId'], '') )
  
  - pwsh: |
      .\SignClient "Sign" `
      --baseDirectory "$(Build.ArtifactStagingDirectory)\vs2022" `
      --input "**\*.vsix" `
      --config "$(Build.Repository.LocalPath)\config\SignClient.json" `
      --filelist "$(Build.Repository.LocalPath)\config\filelist.txt" `
      --user "$(SignClientUser)" `
      --secret '$(SignClientSecret)' `
      --name ".NET nanoFramework VS2019 Extension" `
      --description ".NET nanoFramework VS2019 Extension" `
      --descriptionUrl "https://github.com/$env:Build_Repository_Name"
    displayName: Sign VS2022 packages
    condition: and( succeeded(), eq(variables['System.PullRequest.PullRequestId'], '') )

  # publish artifacts (only possible if this is not a PR originated on a fork)
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)'
      ArtifactName: deployables
      ArtifactType: Container
    condition: and( succeeded(), ne(variables['system.pullrequest.isfork'], true) )
    displayName: Publish deployables artifacts

  # upload extension to Open VSIX Gallery (only possible if this is not a PR from a fork)
  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |

          $artifactsCollection = @("./*VS2019.Extension.vsix", "./*VS2022.Extension.vsix") | %{ Get-ChildItem -File . -Filter $_ -Recurse}

          (new-object Net.WebClient).DownloadString("https://raw.github.com/madskristensen/ExtensionScripts/master/AppVeyor/vsix.ps1") | iex

          foreach($file in $artifactsCollection)
          {
              "Uploading VSIX package to Open VSIX Gallery..." | Write-Host

              Vsix-PublishToGallery $file
          }
    condition: >-
      and(
        succeeded(),
        ne(variables['system.pullrequest.isfork'], true),
        eq(variables['System.PullRequest.PullRequestId'], '')
      )
    displayName: Upload vsix to Open VSIX Gallery

  - powershell: |
      # get subject and commit message for commit
      $commitMessage = git log --format='%B' -1

      # need to flatten message by removing new lines
      $commitMessage = $commitMessage -replace "`r`n", " "

      if($commitMessage -like "*PUBLISH_RELEASE*")
      {
        # set variable
        Write-Host "$("##vso[task.setvariable variable=RELEASE_DRAFT]")false"
        Write-Host "Release draft: FALSE"
      }
      else
      {
        # set variable
        Write-Host "$("##vso[task.setvariable variable=RELEASE_DRAFT]")true"
        Write-Host "Release draft: TRUE"
      }

    displayName: set release draft var

  # create or update GitHub release
  - task: GithubRelease@1
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        not(startsWith(variables['Build.SourceBranch'], 'refs/tags/v'))
      )
    displayName: Create/Update GitHub release
    inputs:
      gitHubConnection: 'github.com_nano-$(System.TeamProject)'
      tagSource: userSpecifiedTag
      tag: v$(NBGV_AssemblyVersion)
      title: '.NET nanoFramework Visual Studio Extension v$(NBGV_AssemblyVersion)'
      releaseNotesSource: inline
      releaseNotesInline: 'Check the [changelog](https://github.com/nanoframework/nf-Visual-Studio-extension/blob/$(Build.SourceBranchName)/CHANGELOG-VS2019.md).<br><br><h4>Install from nanoFramework Open VSIX Gallery development feed</h4><br>The following Visual Studio Extensions are available for install from this release<br><br>:package: [nanoFramework VS2022 Extension](https://marketplace.visualstudio.com/items?itemName=nanoframework.nanoFramework-VS2022-Extension)<br>:package: [nanoFramework VS2019 Extension](https://marketplace.visualstudio.com/items?itemName=nanoframework.nanoFramework-VS2019-Extension)'
      assets: '$(Build.ArtifactStagingDirectory)/*.vsix'
      assetUploadMode: replace
      isPreRelease: true
      addChangeLog: false

  # create or update GitHub release ON tags from release or main branches
  - task: GithubRelease@1
    condition: >-
      and(
        succeeded(),
        startsWith(variables['Build.SourceBranch'], 'refs/tags/v'),
        contains(variables['Build.SourceBranch'], 'vs2019'),
        or(
          eq(variables['Build.SourceBranchName'], 'main'),
          contains(variables['Build.SourceBranchName'], 'release')
        )
      )
    displayName: Create/Update GitHub stable release
    inputs:
      action: edit
      gitHubConnection: 'github.com_nano-$(System.TeamProject)'
      tagSource: userSpecifiedTag
      tag: v$(NBGV_AssemblyVersion)
      title: '.NET nanoFramework Visual Studio Extension v$(NBGV_AssemblyVersion)'
      releaseNotesSource: inline
      releaseNotesInline: 'Check the [changelog](https://github.com/nanoframework/nf-Visual-Studio-extension/blob/$(Build.SourceBranchName)/CHANGELOG-VS2019.md).<br><br><h4>Install from nanoFramework Open VSIX Gallery development feed</h4><br>The following Visual Studio Extensions are available for install from this release<br><br>:package: [nanoFramework VS2022 Extension](http://vsixgallery.com/extension/432ef961-ea3b-4099-ada9-b720ff3a566b)<br>:package: [nanoFramework VS2019 Extension](http://vsixgallery.com/extension/455f2be5-bb07-451e-b351-a9faf3018dc9)'
      assets: '$(Build.ArtifactStagingDirectory)/*.vsix'
      assetUploadMode: replace
      isPreRelease: false
      addChangeLog: false

#################################
- job: Generate_Changelog
  dependsOn:
  - Get_Build_Options
  - VS2019_2022
  condition: >-
    and(
      succeeded('Get_Build_Options'),
      succeeded('VS2019_2022'),
      eq(variables['System.PullRequest.PullRequestId'], '')
    )

  variables:
    myBuildVS2019: $[ dependencies.Get_Build_Options.outputs['BuildOptions.BUILD_VS2019_2022'] ]
    MY_VS2019_VERSION: $[ dependencies.VS2019_2022.outputs['VS2019Build.BUILD_VERSION'] ]
    myBuildVS2022: $[ dependencies.Get_Build_Options.outputs['BuildOptions.BUILD_VS2019_2022'] ]
    MY_VS2022_VERSION: $[ dependencies.VS2019_2022.outputs['VS2019Build.BUILD_VERSION'] ]

  pool:
    vmImage: 'windows-latest'

  steps:
  - checkout: self
    fetchDepth: 10

  - script: |
      git config --global user.email 'nanoframework@outlook.com'
      git config --global user.name 'nfbot'
    displayName: Setup git identity

  - task: UseRubyVersion@0
    inputs:
      versionSpec: '= 2.7'
      addToPath: true
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], '')
      )
    displayName: Setup Ruby

  # install github_changelog_generator
  - powershell: |
        gem install github_changelog_generator --quiet --no-document
    condition: succeeded()
    displayName: Install github_changelog_generator

  # generate VS2019 change log
  - powershell: |
      # need to call it passing both cache options with full path otherwise it won't work
      github_changelog_generator --token $(GitHubToken) --cache-log  $env:AGENT_TEMPDIRECTORY\github-changelog-logger.log --cache-file $env:AGENT_TEMPDIRECTORY\github-changelog-http-cache --since-tag v1.1.0.101-VS2019 --output CHANGELOG-VS2019.md
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        not(startsWith(variables['Build.SourceBranch'], 'refs/tags/v')),
        or(
          eq(variables['Build.SourceBranchName'], 'main'),
          contains(variables['Build.SourceBranchName'], 'release')
        ),
        or(
          eq(variables['myBuildVS2019'], true),
          eq(variables['BUILD_VS2019_2022'], 'true')
        )
      )
    displayName: Generate VS2019 change log

  # generate VS2022 change log
  - powershell: |
      # need to call it passing both cache options with full path otherwise it won't work
      github_changelog_generator --token $(GitHubToken) --cache-log  $env:AGENT_TEMPDIRECTORY\github-changelog-logger.log --cache-file $env:AGENT_TEMPDIRECTORY\github-changelog-http-cache --since-tag v2019.8.0.7 --output CHANGELOG-VS2022.md
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        not(startsWith(variables['Build.SourceBranch'], 'refs/tags/v')),
        or(
          eq(variables['Build.SourceBranchName'], 'main'),
          contains(variables['Build.SourceBranchName'], 'release')
        ),
        or(
          eq(variables['myBuildVS2022'], true),
          eq(variables['BUILD_VS2019_2022'], 'true')
        )
      )
    displayName: Generate VS2022 change log

  # generate VS2019 change log including future version
  - powershell: |
      # need to call it passing both cache options with full path otherwise it won't work
      github_changelog_generator --token $(GitHubToken) --cache-log  $env:AGENT_TEMPDIRECTORY\github-changelog-logger.log --cache-file $env:AGENT_TEMPDIRECTORY\github-changelog-http-cache --since-tag v1.1.0.101-VS2019 --future-release v$(MY_VS2019_VERSION) --output CHANGELOG-VS2019.md
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        startsWith(variables['Build.SourceBranch'], 'refs/tags/v'),
        not(
          or(
            eq(variables['Build.SourceBranchName'], 'main'),
            contains(variables['Build.SourceBranchName'], 'release')
          )
        ),
        or(
          eq(variables['myBuildVS2019'], true),
          eq(variables['BUILD_VS2019_2022'], 'true')
        )
      )
    displayName: Generate VS2019 change log

  # generate VS2022 change log including future version
  - powershell: |
      # need to call it passing both cache options with full path otherwise it won't work
      github_changelog_generator --token $(GitHubToken) --cache-log  $env:AGENT_TEMPDIRECTORY\github-changelog-logger.log --cache-file $env:AGENT_TEMPDIRECTORY\github-changelog-http-cache --since-tag v2019.8.0.7 --future-release v$(MY_VS2022_VERSION) --output CHANGELOG-VS2022.md
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        startsWith(variables['Build.SourceBranch'], 'refs/tags/v'),
        not(
          or(
            eq(variables['Build.SourceBranchName'], 'main'),
            contains(variables['Build.SourceBranchName'], 'release')
          )
        ),
        or(
          eq(variables['myBuildVS2022'], true),
          eq(variables['BUILD_VS2019_2022'], 'true')
        )
      )
    displayName: Generate VS2022 change log

  # copy VS2019 change log to artifacts directory
  - task: CopyFiles@2
    inputs:
      SourceFolder: '$(System.DefaultWorkingDirectory)'
      Contents: |
        'CHANGELOG-VS2019.md'
        'CHANGELOG-VS2022.md'
      TargetFolder: '$(Build.ArtifactStagingDirectory)'
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        not(startsWith(variables['Build.SourceBranch'], 'refs/tags/v')),
        or(
          eq(variables['myBuildVS2019'], true),
          eq(variables['BUILD_VS2019_2022'], 'true')
        )
      )
    displayName: Copy Changelog

  - task: CopyFiles@1
    inputs:
      sourceFolder: $(Build.SourcesDirectory)
      Contents: |
        **\CHANGELOG-VS2019.md
        **\CHANGELOG-VS2022.md
      TargetFolder: '$(Build.ArtifactStagingDirectory)'
      flattenFolders: true
    condition: >-
      and(
        succeeded(),
        or(
          eq(variables['myBuildVS2019'], true),
          eq(variables['BUILD_VS2019_2022'], 'true')
        )
      )
    displayName: Collecting deployable artifacts

  # publish artifacts (only possible if this is not a PR originated on a fork)
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)'
      ArtifactName: deployables
      ArtifactType: Container
    condition: and( succeeded(), ne(variables['system.pullrequest.isfork'], true) )
    displayName: Publish deployables artifacts

  # commit VS2019 changelog
  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            git add CHANGELOG-VS2019.md
            git commit -m "Update CHANGELOG for VS2019 v$env:MY_VS2019_VERSION" -m"***NO_CI***"

    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        not(startsWith(variables['Build.SourceBranch'], 'refs/tags/v')),
        or(
          eq(variables['myBuildVS2019'], true),
          eq(variables['BUILD_VS2019_2022'], 'true')
        )
      )
    displayName: Commit VS2019 changelog

  # commit VS2022 changelog
  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            git add CHANGELOG-VS2022.md
            git commit -m "Update CHANGELOG for VS2019 v$env:MY_VS2022_VERSION" -m"***NO_CI***"

    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        not(startsWith(variables['Build.SourceBranch'], 'refs/tags/v')),
        or(
          eq(variables['myBuildVS2022'], true),
          eq(variables['BUILD_VS2019_2022'], 'true')
        )
      )
    displayName: Commit VS2022 changelog

  # push changelogs to GitHub repo
  - task: PowerShell@2
    inputs:
        targetType: 'inline'
        script: |
            git config user.email 'nanoframework@outlook.com'
            git config user.name 'nfbot'

            # compute authorization header in format "AUTHORIZATION: basic 'encoded token'"
            # 'encoded token' is the Base64 of the string "nfbot:personal-token"
            $auth = "basic $([System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("nfbot:$(GitHubToken)"))))"

            git -c http.extraheader="AUTHORIZATION: $auth" push origin "HEAD:$(Build.SourceBranchName)"

    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        not(startsWith(variables['Build.SourceBranch'], 'refs/tags/v'))
      )
    displayName: Push changelogs to GitHub
